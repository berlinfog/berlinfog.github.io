---
layout:     post
title:     2024-06-01-代码随想录-Day5-哈希表
subtitle:  other
date:       2024-06-01
author:     berlinfog
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - code
---
# 链表


### 今日任务 

#### 242.有效的字母异位词
[力扣题目链接](https://leetcode.cn/problems/valid-anagram/)  

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

说明: 你可以假设字符串只包含小写字母

```
//定义一个数组叫做record用来上记录字符串s里字符出现的次数。

//需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。

//再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。


func isAnagram(s string, t string) bool {
    record := [26]int{}
    for _,v := range s {
        record[v - 'a'] ++
    }
    for _,v := range t {
        record[v - 'a'] --
    }
    return record == [26]int{}
}
```

```
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {
		return false
	}
	records := [26]int{}
	for index := 0; index < len(s); index++ {
		if s[index] == t[index] {
			continue
		}
		sCharIndex := s[index] - 'a'
		records[sCharIndex]++
		tCharIndex := t[index] - 'a'
		records[tCharIndex]--
	}
    
    return records == [26]int{}
}
```

#### 349. 两个数组的交集
[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-arrays/)

题意：给定两个数组，编写一个函数来计算它们的交集。

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
 

提示：

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000



```
func intersection(nums1 []int, nums2 []int) []int {
    set := make(map[int]struct{},0)
    res := make([]int,0)

    for _,v := range nums1{
        if _,sv := set[v];!sv{
            set[v] = struct{}{}
        }
    }

    for _,v := range nums2{
        if _,sv := set[v];sv{
            res = append(res,v)
            delete(set,v)
        }
    }
    return res
}
```

#### 第202题. 快乐数
力扣题目链接[(opens new window)](https://leetcode.cn/problems/happy-number/description/)

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

示例：

输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

```
func getSum(v int) int{
    res := 0
    for v > 0 {
        res += (v % 10) * (v % 10)
        v = v / 10
    }
    return res
}

func isHappy(n int) bool {
    m := make(map[int]bool)
    for n != 1 && !m[n]{
        n,m[n] = getSum(n),true
    }
    return n == 1 
}

//2 4 16 37 58 89 145 42 20 4

```

#### 1. 两数之和
[力扣题目链接](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

```
func twoSum(nums []int, target int) []int {
    mapv := make(map[int]int)
    for i,v := range nums{
        if val,isexist := mapv[target - v]; isexist{
            return []int{val,i}
        }
        mapv[v] = i
    }
    return []int{}
}
```
